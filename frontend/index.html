<!DOCTYPE html>
<html lang="ru">
<head>
  <!-- Основные настройки страницы -->
  <meta charset="UTF-8">
  <title>Парсеры</title>
  <!-- Подключение Bootstrap для стилизации -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="container py-4">
  <!-- Заголовок страницы -->
  <h1 class="mb-4">Выбор парсеров</h1>

  <!-- Форма для выбора парсеров (динамически заполняется JavaScript) -->
  <form id="parserForm" class="mb-3"></form>

  <!-- Кнопки управления -->
  <div class="d-flex gap-2 mb-3">
    <button id="parseBtn" class="btn btn-primary">Парсинг</button>
    <button id="forceParseBtn" class="btn btn-warning">Парсинг в реальном времени</button>
  </div>

  <!-- Блок для отображения статуса выполнения заданий -->
  <div id="status" class="mt-4"></div>

<script>
  // Получаем основные элементы DOM
  const form = document.getElementById('parserForm');
  const statusDiv = document.getElementById('status');

  // Глобальные переменные для хранения данных
  let parsers = [];    // Список доступных парсеров
  let orders = [];      // Список текущих и завершенных заданий

  /**
   * Загружает список доступных парсеров с сервера
   * и создает элементы формы для их выбора
   */
  async function loadParsers() {
    // Запрос к API для получения списка парсеров
    const res = await fetch('/api/availableparsers');
    const data = await res.json();
    parsers = data.parsers;

    // Создаем элементы интерфейса для каждого парсера
    parsers.forEach(parser => {
      const row = document.createElement('div');
      row.className = 'form-check mb-2 d-flex align-items-center gap-3';

      // Чекбокс для выбора парсера
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'form-check-input';
      checkbox.name = 'parser';
      checkbox.value = parser.key;

      // Название парсера
      const label = document.createElement('label');
      label.textContent = parser.name;
      label.className = 'form-check-label me-3';

      // Поле для выбора даты и времени
      const dateInput = document.createElement('input');
      dateInput.type = 'datetime-local';
      dateInput.name = `date_${parser.key}`;
      dateInput.className = 'form-control';
      dateInput.style.maxWidth = '250px';
      dateInput.value = getCurrentLocalDateTime();
      dateInput.style.display = 'none';

      // Добавляем элементы в строку
      row.appendChild(checkbox);
      row.appendChild(label);
      row.appendChild(dateInput);
      form.appendChild(row);
    });
  }

  /**
   * Возвращает текущую дату и время в формате,
   * подходящем для input[type="datetime-local"]
   */
  function getCurrentLocalDateTime() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    return `${year}-${month}-${day}T${hours}:${minutes}`;
  }

  /**
   * Преобразует дату из формата input в строку для API
   * @param {string} inputValue - Дата из input[type="datetime-local"]
   * @returns {string} Дата в формате "ДД.ММ.ГГГГ_ЧЧ-ММ"
   */
  function formatDate(inputValue) {
    const localDate = new Date(inputValue);
    const year = localDate.getUTCFullYear();
    const month = String(localDate.getUTCMonth() + 1).padStart(2, '0');
    const day = String(localDate.getUTCDate()).padStart(2, '0');
    const hours = String(localDate.getUTCHours()).padStart(2, '0');
    const minutes = String(localDate.getUTCMinutes()).padStart(2, '0');
    return `${day}.${month}.${year}_${hours}-${minutes}`;
  }

  /**
   * Проверяет, завершено ли задание (все парсеры отработали)
   * @param {object} order - Объект задания
   * @returns {boolean} true если все парсеры завершили работу
   */
  function isCompleted(order) {
    if (!order.status) return false;
    return Object.values(order.status).every(s => s === 'completed' || s === 'failed');
  }

  /**
   * Отображает список текущих и завершенных заданий
   */
  function renderOrders() {
    statusDiv.innerHTML = '';
    
    for (const order of orders) {
      // Создаем контейнер для задания
      const container = document.createElement('div');
      container.className = 'mb-3 p-2 border rounded';

      // Добавляем ID задания
      const title = document.createElement('p');
      title.innerHTML = `<b>Заказ:</b> ${order.order_id}`;
      container.appendChild(title);

      // Создаем список статусов парсеров
      const list = document.createElement('ul');
      list.className = 'list-group';
      
      for (const [key, status] of Object.entries(order.status)) {
        const item = document.createElement('li');
        item.className = 'list-group-item';
        item.textContent = `${key}: ${status}`;
        list.appendChild(item);
      }
      container.appendChild(list);

      // Если задание завершено - добавляем кнопку скачивания
      if (isCompleted(order) && !container.querySelector('button')) {
        const btn = document.createElement('button');
        btn.textContent = 'Скачать';
        btn.className = 'btn btn-success mt-2';
        btn.onclick = () => downloadZip(order.order_id);
        container.appendChild(btn);
      }

      statusDiv.appendChild(container);
    }
  }

  /**
   * Отправляет запрос на парсинг
   * @param {boolean} isForce - true для принудительного парсинга (без даты)
   */
  async function postParse(isForce) {
    // Получаем выбранные парсеры
    const selected = Array.from(form.querySelectorAll('input[type="checkbox"]:checked'));
    if (selected.length === 0) {
      alert("Выберите хотя бы один парсер");
      return;
    }

    // Формируем данные для отправки
    const source = [];

    for (const checkbox of selected) {
      const key = checkbox.value;
      const dateInput = form.querySelector(`input[name="date_${key}"]`);
      
      // Для обычного парсинга проверяем наличие даты
      if (!isForce && (!dateInput || !dateInput.value)) {
        alert(`Дата не указана для парсера ${key}`);
        return;
      }

      // Добавляем парсер в запрос
      source.push(isForce ? { key } : {
        key,
        datetime: formatDate(dateInput.value)
      });
    }

    // Определяем endpoint в зависимости от типа парсинга
    const endpoint = isForce ? '/api/forceparse' : '/api/parse';
    
    // Отправляем запрос
    const res = await fetch(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ source })
    });

    const data = await res.json();
    const orderId = data.order_id;

    // Создаем новое задание
    const order = {
      order_id: orderId,
      status: {},
      created: new Date().toISOString()
    };

    // Добавляем задание в список и сохраняем
    orders.unshift(order);
    saveOrders();
    renderOrders();
    
    // Начинаем отслеживание статуса
    pollStatus(order);
  }

  /**
   * Опрашивает статус выполнения задания
   * @param {object} order - Объект задания для отслеживания
   */
  async function pollStatus(order) {
    const checkStatus = async () => {
      // Запрос статуса задания
      const res = await fetch('/api/check', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ order_id: order.order_id })
      });

      const data = await res.json();
      
      // Обновляем данные задания
      order.status = data.status.tasks;
      order.updated = new Date().toISOString();

      // Если задание завершено - фиксируем время завершения
      if (isCompleted(order) && !order.completed_at) {
        order.completed_at = new Date().toISOString();
      }

      // Сохраняем и отображаем изменения
      saveOrders();
      renderOrders();

      // Если задание не завершено - продолжаем опрос
      if (!isCompleted(order)) {
        setTimeout(checkStatus, 3000);
      }
    };

    checkStatus();
  }

  /**
   * Скачивает результаты выполнения задания
   * @param {string} orderId - ID задания
   */
  function downloadZip(orderId) {
    fetch('/api/result', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ order_id: orderId })
    })
      .then(res => {
        if (!res.ok) throw new Error('Ошибка при получении файла');
        return res.blob();
      })
      .then(blob => {
        // Создаем временную ссылку для скачивания
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'reports.zip';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      })
      .catch(err => {
        alert('Не удалось скачать файл: ' + err.message);
        console.error(err);
      });
  }

  /**
   * Загружает сохраненные задания из localStorage
   * @returns {Array} Массив заданий (отфильтрованных по времени)
   */
  function loadOrders() {
    const raw = localStorage.getItem('orders');
    if (!raw) return [];

    try {
      const parsed = JSON.parse(raw);
      const now = Date.now();
      const THIRTY_MIN = 30 * 60 * 1000; // 30 минут в миллисекундах

      // Фильтруем задания:
      // - незавершенные оставляем всегда
      // - завершенные - только если они завершились менее 30 минут назад
      return parsed.filter(order => {
        if (!isCompleted(order)) return true;
        const finishedAt = new Date(order.completed_at || order.updated || order.created).getTime();
        return (now - finishedAt) <= THIRTY_MIN;
      });
    } catch {
      return [];
    }
  }

  /**
   * Сохраняет текущие задания в localStorage
   * (с фильтрацией старых завершенных заданий)
   */
  function saveOrders() {
    const now = Date.now();
    const THIRTY_MIN = 30 * 60 * 1000;

    // Фильтруем задания перед сохранением (аналогично loadOrders)
    const filtered = orders.filter(order => {
      if (!isCompleted(order)) return true;
      const finishedAt = new Date(order.completed_at || order.updated || order.created).getTime();
      return (now - finishedAt) <= THIRTY_MIN;
    });

    localStorage.setItem('orders', JSON.stringify(filtered));
  }

  // Назначаем обработчики кнопок
  document.getElementById('parseBtn').onclick = () => postParse(false);
  document.getElementById('forceParseBtn').onclick = () => postParse(true);

  // Создаем кнопку для удаления завершенных заданий
  const deleteBtn = document.createElement('button');
  deleteBtn.className = 'btn btn-danger mb-3';
  deleteBtn.textContent = 'Удалить завершённые заказы';
  deleteBtn.onclick = () => {
    orders = orders.filter(order => !isCompleted(order));
    saveOrders();
    renderOrders();
  };
  document.body.insertBefore(deleteBtn, statusDiv);

  // Инициализация при загрузке страницы
  orders = loadOrders();
  renderOrders();
  
  // Восстанавливаем опрос статуса для незавершенных заданий
  orders.forEach(order => {
    if (!isCompleted(order)) pollStatus(order);
  });

  // Загружаем список парсеров
  loadParsers();
</script>

</body>
</html>